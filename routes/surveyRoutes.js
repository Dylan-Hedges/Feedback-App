//Used for iteration (contains _.map)
const _ = require('lodash');
//Used to extract parts of a URL
const Path = require('path-parser');
//A helper used to parse URLs - 'url' is a default/integrated module in Node.js, URL is a specific helper inside of 'url'
const { URL } = require('url');
const mongoose = require('mongoose');
//Middleware that checks the user is logged in - we dont want users that are not logged in to be able to make surveys
const requireLogin = require('../middlewares/requireLogin');
const requireCredits = require('../middlewares/requireCredits');
const Mailer = require('../services/Mailer');
//Imports the template that produces the html body
const surveyTemplate = require('../services/emailTemplates/surveyTemplate.js');
//Imports the mongoose model class surveys - we can use this to create a new instance of a survey (not yet persisted in our MongoDB)
const Survey = mongoose.model('surveys');

module.exports = app => {
	//Route user is taken to after responding to survey
	app.get('/api/surveys/thanks', (req, res) => {
		res.send('Thanks for voting!');
	});

	app.post('/api/surveys/webhooks', (req, res) => {
		//Creates a matcher - Tells path that want to extract the survey id and choice from "pathname",":surveyId" and ":choice" refers to variables
		const p = new Path('/api/surveys/:surveyId/:choice');

		//Executes multiple lodash helpers in order - ".map" over the list/array of all the events in "req.body" ,".map()" -> ".compact()" -> ".uniqBy()" -> ".value()", "req.body" is a list of all the events when the elements in this list are altered it is automatically passed to the next helper in the chain, we do not have to manually pass on the value, "_" is removed from the start of each helper
		const events = _.chain(req.body)
			//Iterates over the list/array send by SendGrid - "req.body" = the list of events from SendGrid, "({ email, url }) =>{}" for every element in the array (req.body) extract the email and url then execute a function
			.map(({ email, url }) => {
				//Identifies and returns matches - "p.test()" will return an object containing the successful matches or null (needs to extract both the survey id AND choice), takes the parsed URL and runs it agaisnt the matcher("p"), it then returns an object containing the results (in this case "surveyID" and "choice"), "new URL(url).pathname" - Extracts the route portion of the URL
				const match = p.test(new URL(url).pathname);
				//If a match is found
				if (match) {
					//Returns an object containing the users email and the match results (surveyId, users choice)("email" is a destructured version of "email: email" we can do this when the K/V is the same)
					return { email, surveyId: match.surveyId, choice: match.choice };
				}
			})
			//Removes undefined elements - lodash helper, takes an array, goes through all the elements, removes undefined elements (e.g elements we didnt want)
			.compact()
			//Removes duplicate elements - lodash helper, checks using the 'email' AND 'surveyId' properties, if there are any duplicates then it removes them
			.uniqBy('email', 'surveyId')
			//Returns the values - after executing all helpers return the final values as a new array, this is then saved to the "events" variable
			.value();

		console.log(events);

		res.send({});
	});

	//If a user tries to make a new survey (i.e for post requests that come into '/api/surveys') check the user is logged in (execute requireLogin middleware), check the user has enough credits (execute requireCredits middleware), execute callback/create survey, "req" = object that represents the incoming request (contains title, subject, body, recipients(array, "," seperated string of addresses)), creates a new instance of the survey using the model, "async" see "await"
	app.post('/api/surveys', requireLogin, requireCredits, async (req, res) => {
		const { title, subject, body, recipients } = req.body;
		//Creates a  new instance of the survey - title is a shortened version of title: title, we can do this because the Key and Value is the same, recipients - the boolean is set to false by default (not clicked) so doesnt need to be altered, recipients.spilt(',') spilts the string on the "," character, each indivial spilt is a specific email which is storred in an array, ".map()" takes the array of strings and creates a new array of objects (loops through the array of strings and executes a function for each element in the array), "(email => ({ email }))" short for "(email => { return { email: email}})" - for every email address return an object with the property email + the email, "req.user.id" - id generated by mongoose/mongo, "dateSent: Date.now()" - saves when the survey was sent
		const survey = new Survey({
			title,
			subject,
			body,
			recipients: recipients.split(',').map(email => ({ email: email.trim() })),
			_user: req.user.id,
			dateSent: Date.now()
		});

		//Creates a new Mailer instance - "(survey)" passes in an object that contains the "subject" and "recipients" properties, "surveyTemplate(survey)" content of the email (html) - calls the function inside of surveyTemplate.js and passes in the "survey" object/model (defined above), "new" - creates a new instance of a class,
		const mailer = new Mailer(survey, surveyTemplate(survey));

		//Catches any errors when sending mails, saving surveys, minus credits etc.
		try {
			//".send()" is an async function (we have to wait for API request inside of it to complete (i.e mailer sent to SendGrid) before we send the survey), "await" refers to "app.post()"
			await mailer.send();
			//Saves the survey to the DB (after sending to SendGate API), "await" - wait until the ".send();" request to the SendGrid API is complete before saving to the DB
			await survey.save();
			//Minus 1 credit from users account
			req.user.credits -= 1;
			//Save the updated user
			const user = await req.user.save();
			//Send back user model with updated number of credits
			res.send(user);
		} catch (err) {
			//Sends a response code with the error if any issues
			res.status(422).send(err);
		}
	});
};
